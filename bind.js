//При передаче методов объекта в качестве колбэков, например для setTimeout,
// возникает известная проблема – потеря this.

//Как только метод передаётся отдельно от объекта – this теряется.
//
// Вот как это может произойти в случае с setTimeout:
let user = {
  firstName: "Вася",
  sayHi() {
    console.log(`Привет, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!
//вызов this.firstName возвращает не «Вася», а undefined!
// Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user
// (именно здесь функция и потеряла контекст).
// То есть последняя строка может быть переписана как:
//
// let f = user.sayHi;
// setTimeout(f, 1000); // контекст user потеряли

//Решение 1: сделать функцию-обёртку, создав замыкание:

setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
// Теперь код работает корректно, так как объект user достаётся из замыкания,
// а затем вызывается его метод sayHi.
// То же самое, только короче:
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
// Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.
//если до момента срабатывания setTimeout (ведь задержка составляет целую секунду!)
// в переменную user будет записано другое значение?
// Тогда вызов неожиданно будет совсем не тот!
user = { sayHi() { console.log("Другой пользователь в 'setTimeout'!"); } };

//Решение 2: привязать контекст с помощью bind

//Базовый синтаксис bind:
// полный синтаксис будет представлен немного позже
//let boundFunc = func.bind(context);
// Результатом вызова func.bind(context) является особый «экзотический объект»
// (термин взят из спецификации), который вызывается как функция и
// прозрачно передаёт вызов в func, при этом устанавливая this=context.
// Другими словами, вызов boundFunc подобен вызову func с фиксированным this.

user = {
  firstName: "Вася",
  sayHi() { console.log(`Привет, ${this.firstName}!`)} };
let sayHi = user.sayHi.bind(user); // (*)
//user.firstName = 'Kolya';
sayHi(); // Привет, Вася!

setTimeout(sayHi, 15000); // Привет, Вася!
//В строке (*) мы берём метод user.sayHi и привязываем его к user.
// Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или
// передана в setTimeout (контекст всегда будет правильным).

//Здесь мы можем увидеть, что bind исправляет только this,
// а аргументы передаются как есть:
user1 = {
  firstName: "Vasya",
  say(phrase) {
    console.log(`${phrase}, ${this.firstName}!`);
  }
};

let say = user1.say.bind(user1);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася (аргумент "Пока" передан в функцию "say")

//Удобный метод: bindAll
//Если у объекта много методов и мы планируем их активно передавать,
// то можно привязать контекст для них всех в цикле:
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
console.log('===============');

//Частичное применение
//Мы можем привязать не только this, но и аргументы.
// Это делается редко, но иногда может быть полезно.
//Полный синтаксис bind:

 //   let bound = func.bind(context, [arg1], [arg2], ...);
//    let boundFunc = func.bind(context); nepolnii syntax

//Это позволяет привязать контекст this и начальные аргументы функции.
//Например, у нас есть функция умножения mult(a, b):

function mult(a, b) {
  return a * b;
}
//Давайте воспользуемся bind, чтобы создать функцию double на её основе:
console.log('double');
let double = mult.bind(null, 2);

console.log( double(3) ); // = mul(2, 3) = 6
console.log( double(4) ); // = mul(2, 4) = 8
console.log( double(5) ); // = mul(2, 5) = 10

//Вызов mult.bind(null, 2) создаёт новую функцию double,
// которая передаёт вызов mul, фиксируя null как контекст,
// и 2 – как первый аргумент. Следующие аргументы передаются как есть.
//Это называется частичное применение – мы создаём новую функцию,
// фиксируя некоторые из существующих параметров.
//Обратите внимание, что в данном случае мы на самом деле не используем this.
// Но для bind это обязательный параметр,
// так что мы должны передать туда что-нибудь вроде null.

//В следующем коде функция triple умножает значение на три:
console.log('triple');
let triple = mult.bind(null, 3);

console.log( triple(3) ); // = mul(3, 3) = 9
console.log( triple(4) ); // = mul(3, 4) = 12
console.log( triple(5) ); // = mul(3, 5) = 15

